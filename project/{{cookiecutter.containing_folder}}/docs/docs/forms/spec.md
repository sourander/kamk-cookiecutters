# The Spec

## Architecture

Even though we are avoiding the Big Design Up Front (BDUF), we still need to have a high-level architecture in mind. This is to ensure that the system is scalable, maintainable, and everyone in the team is on the same page. If need be, you can move this arcitechture to a separate document. For now, it is here for the sake of simplicity.

!!! warning "Avoid spaghetti architecture"

    Remember that every system has an architecture. It is either by design or by accident. The latter is most likely a [big ball of mud](http://www.laputan.org/mud/mud.html) or spaghetti architecture.

    > A BIG BALL OF MUD is haphazardly structured, sprawling, sloppy, duct-tape and bailing wire, spaghetti code jungle. Weâ€™ve all seen them. These systems show unmistakable signs of unregulated growth, and repeated, expedient repair. Information is shared promiscuously among distant elements of the system, often to the point where nearly all the important information becomes global or duplicated. The overall structure of the system may never have been well defined. If it was, it may have eroded beyond recognition. <br> - Brian Foote & Joseph Yoder

    

### High-Level Architecture

Prefer to use diagrams to explain the architecture. This is the high-level architecture, the 30,000 foot view. It should be simple enough to be understood by a non-technical person. It should clarify the system's major components ("raviolis") and their interactions. This reveals the inter-component communication, data flow and dependencies.

```mermaid
graph TD
    A[Client] -->|Request| B[Server]
    B -->|Response| A
```

### Component Diagrams

#### Component 1

Add diagrams explaining the architecture of any components of your system. Below is a dummy example of the server component (from the high-level architecture). This is the 10,000 foot view. Understanding it may require some technical knowledge, but it should NOT be a deep dive into a single component.

```puml
@startuml

actor User

card "Component 1" {
    rectangle "Frontend" as front

    rectangle Backend as back {

        rectangle Auth as auth.local {
            card "Username\nPassword"
        }

        rectangle API {
            card "Public" as api.pub
            card "Private" as api.priv
        }

        database "Storage" as storage.local
    }

    front --> API
    API -up-> storage.local
    API -up-> auth.local
}

User --> front
@enduml
```

#### Component 2

Here you would explain the architecture of another component. You may use different kind of diagrams based on the component's nature. Check the PlantUML reference guide for examples. The potential diagrams include:

* Sequence diagram
* Usecase diagram
* Activity diagram
* Component diagram
* Deployment diagram
* State diagram
* Timing diagram

Below is an example of a sequence diagram (from PlantUML's language referend guide, page 3).

```puml
@startuml
actor Bob #red
' The only difference between actor
'and participant is the drawing
participant Alice
participant "I have a really\nlong name" as L #99FF99
/' You can also declare:
participant L as "I have a really\nlong name" #99FF99
'/
Alice->Bob: Authentication Request
Bob->Alice: Authentication Response
Bob->L: Log transaction
@enduml
```


## Data Model

This heading is for the data model. Components of the system typically transfer data between each other. This data has a structure. This structure is the data model.

The actual contents depend on what you are building. It could be a database schema, a data flow diagram - or - maybe **a link to**  autogenerated documentation runnning in a another container (within the same Docker compose network, exposed to another port). For example, if you are using Pydantic or protobuf to define your schema as a code, it wouldn't make a lot of sense to manually copy-paste the contents here. Instead, use tools of automation! The team has a lot of freedom over this. Use that freedom wisely.

In simple cases, you might simply write the data model in a YAML format. Below is an example of a ultra simple data model (adapted from PlantUML's language reference guide, page 273).

```puml
@startyaml
fruit (VARCHAR): Apple
size (ENUM): 
- Small
- Large
color (ENUM):
- Red
- Green
@endyaml
```

## Product Schedule

Some projects are continuous, some are not. Our University projects have a set deadline. Visualize it below using a Gantt chart. Also, if there are some expected events that affect the project, add them to the chart. For example, if you are expecting a hardware device to arrive, add it to the chart. Or maybe the client wants to see a demo at a certain date. Add it to the chart.

```puml
@startgantt
Project starts 2024-03-20
[xxx] starts 2024-03-20 and ends 2024-03-24
[yyy] starts at [xxx]'s end
[yyy] ends 2024-03-31

[sprint 0] starts at 2024-04-03 and lasts 7 days

[sprint 1] starts at [sprint 0]'s end and lasts 7 days
[Hardware device No.1 is expected to arrive] happens at [sprint 1]'s end

[sprint 2] starts at [sprint 1]'s end and lasts 7 days

[sprint 3] starts at [sprint 2]'s end and lasts 7 days
[Client wants to see a demo] happens at [sprint 3]'s end

[sprint 4] starts at [sprint 3]'s end and lasts 7 days
[sprint 5] starts at [sprint 4]'s end and lasts 7 days
[sprint 6] starts at [sprint 5]'s end and lasts 7 days

[Final Demo] happens at 2024-05-24

@endgantt
```
